// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package domain

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// SkillNameBasicAttack is a SkillName of type BasicAttack.
	SkillNameBasicAttack SkillName = "普通攻擊"
	// SkillNameCheerUp is a SkillName of type CheerUp.
	SkillNameCheerUp SkillName = "鼓舞"
	// SkillNameCurse is a SkillName of type Curse.
	SkillNameCurse SkillName = "詛咒"
	// SkillNameFireBall is a SkillName of type FireBall.
	SkillNameFireBall SkillName = "火球"
	// SkillNameWaterBall is a SkillName of type WaterBall.
	SkillNameWaterBall SkillName = "水球"
	// SkillNameOnePunch is a SkillName of type OnePunch.
	SkillNameOnePunch SkillName = "一拳攻擊"
	// SkillNamePetrochemical is a SkillName of type Petrochemical.
	SkillNamePetrochemical SkillName = "石化"
	// SkillNamePoison is a SkillName of type Poison.
	SkillNamePoison SkillName = "下毒"
	// SkillNameSelfExplosion is a SkillName of type SelfExplosion.
	SkillNameSelfExplosion SkillName = "自爆"
	// SkillNameSelfHealing is a SkillName of type SelfHealing.
	SkillNameSelfHealing SkillName = "自我治療"
	// SkillNameSummon is a SkillName of type Summon.
	SkillNameSummon SkillName = "召喚"
)

var ErrInvalidSkillName = errors.New("not a valid SkillName")

// String implements the Stringer interface.
func (x SkillName) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x SkillName) IsValid() bool {
	_, err := ParseSkillName(string(x))
	return err == nil
}

var _SkillNameValue = map[string]SkillName{
	"普通攻擊": SkillNameBasicAttack,
	"鼓舞":   SkillNameCheerUp,
	"詛咒":   SkillNameCurse,
	"火球":   SkillNameFireBall,
	"水球":   SkillNameWaterBall,
	"一拳攻擊": SkillNameOnePunch,
	"石化":   SkillNamePetrochemical,
	"下毒":   SkillNamePoison,
	"自爆":   SkillNameSelfExplosion,
	"自我治療": SkillNameSelfHealing,
	"召喚":   SkillNameSummon,
}

// ParseSkillName attempts to convert a string to a SkillName.
func ParseSkillName(name string) (SkillName, error) {
	if x, ok := _SkillNameValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SkillNameValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SkillName(""), fmt.Errorf("%s is %w", name, ErrInvalidSkillName)
}
