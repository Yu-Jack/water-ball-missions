// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package domain

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// ActionOptionMove is a ActionOption of type Move.
	ActionOptionMove ActionOption = "移動"
	// ActionOptionAttack is a ActionOption of type Attack.
	ActionOptionAttack ActionOption = "攻擊"
)

var ErrInvalidActionOption = errors.New("not a valid ActionOption")

// String implements the Stringer interface.
func (x ActionOption) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x ActionOption) IsValid() bool {
	_, err := ParseActionOption(string(x))
	return err == nil
}

var _ActionOptionValue = map[string]ActionOption{
	"移動": ActionOptionMove,
	"攻擊": ActionOptionAttack,
}

// ParseActionOption attempts to convert a string to a ActionOption.
func ParseActionOption(name string) (ActionOption, error) {
	if x, ok := _ActionOptionValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ActionOptionValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ActionOption(""), fmt.Errorf("%s is %w", name, ErrInvalidActionOption)
}

const (
	// AttackScopeOne is a AttackScope of type One.
	AttackScopeOne AttackScope = "單點攻擊"
	// AttackScopeLine is a AttackScope of type Line.
	AttackScopeLine AttackScope = "一條線攻擊"
	// AttackScopeAll is a AttackScope of type All.
	AttackScopeAll AttackScope = "全範圍攻擊"
)

var ErrInvalidAttackScope = errors.New("not a valid AttackScope")

// String implements the Stringer interface.
func (x AttackScope) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x AttackScope) IsValid() bool {
	_, err := ParseAttackScope(string(x))
	return err == nil
}

var _AttackScopeValue = map[string]AttackScope{
	"單點攻擊":  AttackScopeOne,
	"一條線攻擊": AttackScopeLine,
	"全範圍攻擊": AttackScopeAll,
}

// ParseAttackScope attempts to convert a string to a AttackScope.
func ParseAttackScope(name string) (AttackScope, error) {
	if x, ok := _AttackScopeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AttackScopeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AttackScope(""), fmt.Errorf("%s is %w", name, ErrInvalidAttackScope)
}

const (
	// DirectionUp is a Direction of type Up.
	DirectionUp Direction = "↑"
	// DirectionDown is a Direction of type Down.
	DirectionDown Direction = "↓"
	// DirectionLeft is a Direction of type Left.
	DirectionLeft Direction = "←"
	// DirectionRight is a Direction of type Right.
	DirectionRight Direction = "→"
)

var ErrInvalidDirection = errors.New("not a valid Direction")

// String implements the Stringer interface.
func (x Direction) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x Direction) IsValid() bool {
	_, err := ParseDirection(string(x))
	return err == nil
}

var _DirectionValue = map[string]Direction{
	"↑": DirectionUp,
	"↓": DirectionDown,
	"←": DirectionLeft,
	"→": DirectionRight,
}

// ParseDirection attempts to convert a string to a Direction.
func ParseDirection(name string) (Direction, error) {
	if x, ok := _DirectionValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _DirectionValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Direction(""), fmt.Errorf("%s is %w", name, ErrInvalidDirection)
}

const (
	// RoleNameMonster is a RoleName of type Monster.
	RoleNameMonster RoleName = iota
	// RoleNameCharacter is a RoleName of type Character.
	RoleNameCharacter
)

var ErrInvalidRoleName = errors.New("not a valid RoleName")

const _RoleNameName = "MonsterCharacter"

var _RoleNameMap = map[RoleName]string{
	RoleNameMonster:   _RoleNameName[0:7],
	RoleNameCharacter: _RoleNameName[7:16],
}

// String implements the Stringer interface.
func (x RoleName) String() string {
	if str, ok := _RoleNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RoleName(%d)", x)
}

var _RoleNameValue = map[string]RoleName{
	_RoleNameName[0:7]:                   RoleNameMonster,
	strings.ToLower(_RoleNameName[0:7]):  RoleNameMonster,
	_RoleNameName[7:16]:                  RoleNameCharacter,
	strings.ToLower(_RoleNameName[7:16]): RoleNameCharacter,
}

// ParseRoleName attempts to convert a string to a RoleName.
func ParseRoleName(name string) (RoleName, error) {
	if x, ok := _RoleNameValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _RoleNameValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return RoleName(0), fmt.Errorf("%s is %w", name, ErrInvalidRoleName)
}
